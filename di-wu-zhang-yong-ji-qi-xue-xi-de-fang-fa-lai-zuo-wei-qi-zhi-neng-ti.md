# 第五章 第一个围棋智能体

传统的基于监督学习的方法得

## 围棋棋谱

棋谱是一盘棋局对弈发展的过程纪录，是用图和文字记述棋局的基本技术和开局、中局、残局着法的书和图谱，按所记述的棋局排演，可参考吸收其着法，或探讨研究名手的棋艺风格。不同的棋戏会有不同的棋谱，按棋种分中国象棋棋谱、国际象棋谱、围棋棋谱、五子棋棋谱等。

![](.gitbook/assets/bu-huo-%20%281%29.png)

围棋谱是围棋对弈过程的记录，在纸上画上棋盘，并在黑、白棋双方落子的位置上注明该手手数。围棋的传播和发展，离不开棋谱的编撰和出版。我国围棋谱的产生年代，据现有文献资料，还不能推到汉朝以前。《敦煌棋经》指出：汉朝时有《汉图十三势》；三国时有《吴图二十四》，这两本围棋谱大概算得上是我国最古的棋谱了。到了晋朝，有棋圣之称的马绥明等人撰写了《围棋势》29卷，这是我国古代卷数最多的一套围棋谱。这些编撰成集、经过校定的围棋谱，无疑都是当时名棋手对局中的精华。它们的流传，对围棋的发展起了不可低估的作用。遗憾的是，这些宝贵的棋谱后来全部失传。但值得庆幸的是，在现今，我们可以将棋谱保存为电子档格式以供软件阅读和人们打谱。其中，SGF和PGN是两种最常见的棋谱电子档格式。国际象棋以PGN作为记录棋谱的标准规范。网络围棋使用SGF格式作为记录围棋棋局的格式，绝大多数围棋软件都在使用它。SGF和PGN不是专门为某一种棋类设计的棋谱格式，它们最初设计的目的都是为了可以记录所有棋类游戏的棋谱，所以用SGF格式记录国际象棋的棋谱和用PGN格式记录围棋的棋谱都是可行的。 目前最通用的围棋棋谱格式是SGF格式，我们这里选择使用这种格式来保存围棋棋谱。额外说一句题外话，中国象棋的电子棋谱采用什么格式保存目前还没有统一的标准，由于PGN在国际象棋棋谱上的地位，采用PGN格式来记录中国象棋会是一个好的选择。

SGF文件是由一组属性和属性对应的值组成的。它存储的内容是纯文本，可以移植到不同的平台，并且短小精悍。下面的这串文本就记录了一个完整的SGF格式文件。

$$
(;FF[4]GM[1]RE[W+26.5]SZ[19];B[pd];W[dd])
$$

读者可以使用任何支持SGF格式文件的围棋软件打开它。这个仅41个字符的文本就是一张棋谱，为了演示方便，它只有2手，在Sabaki里显示如下：

![](.gitbook/assets/bu-huo-.png)

SGF文件记录整张棋谱时以左括号开始，以右括号结束，每个信息段落以分号开头。棋局的基本信息必须记录在SGF文件的第一个段落里，一般把它看作是文件头。关于棋局的信息记录在后续的段落是无效的。双方每一步落子都是一个独立的段落。记录的属性用大写英文字母表示，属性对应的值紧跟在属性之后，用一组方括号提示。下表列出了常见的属性，对于设计一款围棋智能软件，这些信息已经足够了。读者如果想要了解更多详细的内容可以参考[这里](https://www.red-bean.com/sgf/user_guide/index.html)的介绍。

| 属性 | 定义 |
| :---: | :--- |
| GM | 游戏种类，1代表围棋 |
| RE | 比赛结果，\[W+26.5\]表示白棋胜26.5目 |
| SZ | 棋盘尺寸大小 |
| FF | SGF采用的版本，目前第四版是最新版本 |
| HA | 表示让子数，0表示分先 |
| KM | 表示贴多少目 |
| B | 黑棋落子，\[pd\]表示右上角星位 |
| W | 白棋落子，\[dd\]表示左上角星位 |

SGF的棋盘坐标与我们常见的很不一样，它以棋盘的左上角为原点，横轴和纵轴均由字母a开始逐个往后排，直到s（19路棋盘）结束。在记录落子方位时，先数横轴再数纵轴。

![](.gitbook/assets/ta2.gif)

用Python语言操作SGF文件可以使用现成的库，还是那句话，我们要尽量避免重复造轮子，努力站在巨人的肩膀上。Gomill是一个非常优秀的SGF文件操作库，唯一的遗憾是它只支持Python 2.x，而Python 2.x的支持在2020年就结束了，目前作者Matthew Woodcraft似乎也没有将它移植到Python 3.x的意愿。所幸作者还提供了一个功能简化版的sgfmill库，这个库可以在Python 3.x上使用，而且工作的相当好。对我们读写SGF文件来说sgfmill已经足够了。我们通过gomill或者sgfmill为sgf文件生成一个文档结构图，引入文档结构图的概念使得操作sgf文件和操作xml文件一样简单方便。

## 数据模型

要用神经网络来学习围棋，首先要将围棋数字话。本书代码中的样例中用数字1代表黑棋，-1代表白棋。棋盘上的空子用0表示。5路棋盘就用一个（5，5）的数组来表示。

![](.gitbook/assets/qipanshuzihua.svg)

除了有棋盘的局面，如果需要神经网络给出落子建议，我们还需要告诉神经网络当前是轮到谁落子，显然同一局面，不同的落子方会导致有不同的选择。



![](.gitbook/assets/luozijiany.svg)

一种通知神经网络哪方落子的方法是为神经网络增加一个输入，用1和-1来分表表示应该是黑棋还是白棋落子。

通常为了神经网络在结构上表达能够尽量简洁，我们习惯只为网络设置单一的输入接口，

![](.gitbook/assets/moxing.svg)

考虑到棋盘局面是一个二维数据，如果我们用卷积网络来收集图形特征的信息，可以考虑为卷积网络的输入再多增加一个通道，用这个通道的数据来表示当前应当是黑棋还是白棋落子。这种方法好处是实现上要比上一种方法简单，缺点是必须要使用卷积网络，但是考虑到围棋棋盘采用卷积网络能获取到更好的图形特征，所以对于围棋而言这并不算是一个缺点。

![](.gitbook/assets/lzshuju.svg)

本书的代码样例中上述两种方法都有使用，本章采用第一种方式，即通过卷积网络提取棋盘局面的特征，而后将盘面特征再结合当前落子方输入到逻辑判断网络进行最后的落子选择。

## 获取训练样本

u-go.net是一个围棋爱好者的网站，我们能从上面免费下载到[K Go Server](http://www.gokgs.com/)（KGS）网站上棋手的对战记录。这些对战记录都被保存为SGF格式文件。网站提供了[7段以上](https://u-go.net/gamerecords/)或[4段以上](https://u-go.net/gamerecords-4d/)棋手的对弈记录。通常为了保证机器学习后的下棋棋力，可以采用7段以上的对弈棋谱，如果样本偏少的话，再考虑使用4段以上的棋谱。为了保证学习的质量，我们可以只采用单局胜利方的落子法作为样本标签。网站上还提供了其它一些可以下载到专业级选手的下棋棋谱的[链接](https://www.u-go.net/links/gamerecords/)，但是其中大部分是收费的。

围棋棋盘本身是没有方向性的，比如开局时第一个子落在哪个星位对对手而言并没有什么区别。但是对于计算机而言，它自身并没有人类那种能自适应的能力，特别是我们通过卷积网络来提取特征值时，网络对物体特征的位置或者方向是很敏感的。图像识别的人工智能训练中有一种称作数据增强的技术，方式是通过旋转或者翻转原始样本来增加神经网络训练时的样本集，使得神经网络在训练后能够识别倒转的或者不同角度的目标物体。在训练围棋智能体的时候，为了提高训练的效率，我们也采用类似的技术。由于围棋棋盘总是一个四方形，在获取一个训练样本后，我们可以对样本进行90度，180度，270的旋转，同时还可以对样本进行水平进行，并再次进行旋转。这样，一个样本通过这种技术处理后，就变成了8个样本。

![1&#x4E2A;&#x6837;&#x672C;&#x5904;&#x7406;&#x6210;8&#x4E2A;&#x6837;&#x672C;](.gitbook/assets/sin%20%2812%29.svg)

由于人工棋谱的数量相对于机器学习所需要的数量来说还是相对偏少的，通过上述技术可以缓解这个问题，但是要从根本上解决，必须要将样本生成的过程变成自动化。最方便的产生棋谱的方式是使用现有的围棋智能程序来相互对弈，通过这种方式我们可以产生源源不断的围棋棋谱。但是这种方式有一个致命的缺点，就是被训练的智能程序在棋力上很难突破原有的智能系统。这个致命缺点也是传统的以监督学习为核心算法的人工智能的一个通病。在后面的章节中我们将看到其它更加有效的方法来增强围棋智能体的训练结果，不过目前而言，通过这种传统方法，我们的围棋智能体在棋力上已经能够胜过随机落子的系统了。

## 代码演示

{% code title="myGO/sample\_loader.py" %}
```python
filePath="./game_recorders/game_recorders.h5"                #1
games=HDF5(filePath,mode='r')                #2
type='pd_dense'                #3
model=DenseModel(dataGenerator=games.yeilds_data,
                boardSize=9,dataSize=1024*100,model=type)                #4
```
{% endcode %}

1. 学习样本的数据存放在HDF5的格式文件中。训练样本可以从历史棋局中获取，也可以通过程序来自动生成，如何通过程序来自动生成棋谱将在通用化围棋AI程序中进行介绍；
2. 通过games来实现从存储样本的HDF5文件中获取训练样本和对应的标签；
3. 我们在DenseModel中预定义了网络模型，pd\_dense类型包含了是一个可选的参数用来指定是使用全连接网络还是卷积网络，默认是卷积网络。type也可以直接设定为cnn，从而显示地指出使用卷积网络；
4. 调用预定义的DenseModel神经模型。使用games中的数据发生器来产生源源不断的训练数据。数据发生器是一项非常好用的技术，特别是对于样本数据量巨大的训练过程，系统由于内存限制，不可能一次性载入全部数据，通过这项继续，训练过程可以逐个按需获取训练样本。附录《Keras入门指南》中有对这项技术的详细介绍。

{% code title="myGO/sample\_loader.py" %}
```python
model.model_compile()    #1
model.model_fit(batch_size=16*2,epochs=10000,earlystop=10,checkpoint=True)    #2
model.model_save(type+'.h5')    #3
```
{% endcode %}

1. 使用DenseModel预定义好的梯度优化算法和误差函数；
2. 开始训练，这里使用了早停和记录网络参数的功能。由于我们训练回合过多，对训练效果也不清楚，所以使用早停和参数记录避免由于网络设计不合理导致的训练时间浪费；
3. 训练完成后保存模型。

使用Keras来做传统的神经网络训练十分的方便，代码写作方式也基本固定，我们仅需要在参数选择上进行调整。我们可以使用`myGO/test_fast_play.py`来看一下使用这种训练方法的棋力。

{% code title="myGO/sample\_loader.py" %}
```python
from board_fast import * #1

board = Board(size=9)
bot1=None    #1
bot2=Robot(ai='SD',boardSize=9,model='pd_dense')    #2
game=Game(board)
print(game.run(play_b=bot1,play_w=bot2,isprint=True))    #3
```
{% endcode %}

1. 引入board\_fast工具下的所有方法方便后续调用；
2. bot1设置手工输入，bot2采用我们刚刚训练好的模型。Robot方法默认装载入`myGO/`下的`lj.h5`神经网络权重文件，所以在使用训练结果时要记得手工调整一下训练结果文件的文件名；
3. 调用起棋局，并打印出胜负结果。

