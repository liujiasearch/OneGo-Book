# HDF5文件结构

HDF5格式的文件是一种常见的跨平台数据储存文件，是存储和组织大量数据的一组文件格式，它常被用来存储不同类型的图像和数码数据。由于机器学习需要使用大量的数据，HDF5文件是存放训练样本和标签的一个非常好的选择。

HDF5的文件结构非常简单， 文件中的资源采用类似POSIX语法的“/路径/至/资源”来访问。它包含两种主要的对象类型，数据集（dataset）和群组（group）。 群组类似于文件夹，每个HDF5文件其实就是文件夹的根目录。而数据集则类似于Numpy中的数组。数据集除了存放数据本身，还可以为数据增加额外的属性值。比如，在DHF5文件中存放了一张图片，如果我想为这个图片数据额外增加图片内容的描述，便可以为这张图片增加一个图片描述的属性。属性本身没有个数限制，可以根据应用场景的实际需要进行添加。Python中可以使用h5py这个库来处理HDF5格式的文件。

本书本书使用HDF5格式文件来保存棋局中的每一个棋面情况。HDF5的结构采用扁平化的方式，即每一局棋保存为一个单独的群组，一局棋的每一个棋面情况均保存为一个单独的数据集。假设一局棋黑棋执先，在第70手的时候白棋投子认输，那么这局棋将会单独保存为一个群组（group），并且这个群组下会有70个数据集（dataset）。如果将1000局棋局保存到一个HDF5文件中，那么这个HDF5文件里就会有1000个并列的群组。

![&#x672C;&#x4E66;&#x91C7;&#x7528;&#x7684;HDF5&#x6587;&#x4EF6;&#x5185;&#x90E8;&#x7ED3;&#x6784;](.gitbook/assets/wei-ming-ming-hui-tu-37%20%281%29.svg)

我们以上图6\*6的棋盘为例。棋盘可以用一个二维的6\*6的矩阵表示，空棋盘用数字0表示，黑棋棋子用1表示，白棋棋子用-1来表示。输入棋盘可以表示为矩阵：

$$
样本棋盘： \left[
 \begin{matrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & -1 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0
  \end{matrix}
  \right]
$$

对于输出标签来说，我们没有用1和-1来表示黑棋和白棋，而是仅用数字1来标注落子的位置，并把当前落子方的颜色信息保存到HDF5数据集的属性里。读者如果采用1和-1这种方式来标注落子位置也没有问题。

$$
落子标签：  \left[
 \begin{matrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 &0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0
  \end{matrix}
  \right]
$$

神经网络的训练过程需要将HD5文件中的样本解析出来。数据集中的棋盘局面可以直接提取后直接输入卷积网络进行特征提取。从属性中取出样本标签用于神经网络的损失计算和反向传播。落子方信息从属性中提取后不用参与棋盘局面的特征提取，而是在之后的逻辑判断中再进行输入。

![](.gitbook/assets/jian-dan-shen-jing-wang-luo-jia-gou-.svg)

![HDF5&#x6570;&#x636E;&#x63D0;&#x53D6;&#x540E;&#x7684;&#x4F7F;&#x7528;&#x56FE;&#x4F8B;](.gitbook/assets/cnn.svg)

我们借鉴著名的inception网络来构建我们的围棋智能模型。Inception是深度网络，它采用深度网络。。。。我们不打算使用像inception那么深的网络，这里我们只借鉴Inception的一组模块用于棋盘的棋形识别，然后还是和之前的感知网络一样，我们使用全连接层来做逻辑判断。为了平滑地从卷积网络过渡到感知网络，我们使最后一层卷积的输出是一个1\_1\_c的形状，然后再使用flatten功能把这层展开为感知网络。

在机器学习中，样本常常不能一次性获取全部完整的样本，它总是一点一点积累的。在围棋训练样本这件事情上也是一样，我们总是得到一些棋谱就希望拿来作为训练样本，等有新的赛事结束后再把新的棋谱拿来做新的样本。每次获取到新的样本集后我们都可以为其独立生成一个HDF5文件，而不用每次都全量重新生成一个单独的HDF5文件。在训练时，每次都从文件系统上随机抽取HDF5文件会增加磁盘IO的开销。由于我们的HDF5文件结构非常简单，从理论上看，只要保证group名不重复，把新增的HDF5文件合并到原来的HDF5文件上是完全可行的。技术上，[hdf5官方套件](https://www.hdfgroup.org/solutions/hdf5/)提供了一个叫做h5copy的命令行工具，但在使用它之前，需要下载完整的HDF5应用程序，Windows用户可以在官网上直接下载。

n仅指最近的下一层节点访问的次数。由于落子的顺序不同，会存在上一层不同的棋形共享下一层的情况，因此N&lt;=n。为了辨识出共享棋形的子节点，我们用佐布里斯特散列来标识唯一的棋形，也就是节点。

![alphagozero&#x7684;&#x7F51;&#x7EDC;](.gitbook/assets/wang-luo-jie-gou-.svg)

alphagozero的网络在结构上和ac网络类似，差异仅仅在于学习方式上的不同

如何判定算法已经找到了最优解？我的AI程序已经训练一千万次了，没有人类选手能够击败它了，是不是意味着我的AI程序已经找到了围棋的最佳拟合函数呢？围棋本身可能并不是一款零和游戏，不过人们根据长久的围棋游戏经验，规定了在游戏结算时进行贴目，这样可以使得原本不是零和的游戏成为零和游戏。但是贴多少目才能保证游戏的公平性一直没有定论。假使有一款围棋AI已经能够以无限接近的方式拟合了围棋游戏的函数F\(x\)，通过让这款AI进行互弈，将胜利方多出的目数贴给失败方，我们就能解决贴多少目是公平的这个问题。确定AI是否已经最佳拟合了围棋的函数F\(x\)也很简单，通过反复的互弈，如果每次胜利方都是先手并且获胜的目数是固定的，那么我们就可以认为AI已经最佳拟合围棋的函数F\(x\)。所以如果现在没有一款AI程序可以做到这一点，那么围棋AI的算法就还需要改进，人类肯定已经不是挑战的目标了，现在已经变成了机器智能间的竞争。

![](.gitbook/assets/jia-zhi-wang-luo-1.svg)

![](.gitbook/assets/jia-zhi-wang-luo-2.svg)

在编写价值网络的时候，棋盘编码可以有两种，其实现难度也不同。一种是比较直观的方法，棋盘的棋形输入和落子着法分开，我们把他们看作是两件事。这种编码方式下，我们使用卷积网络提取当前棋盘局势的特征，然后再合并落子的着法，将它们输入逻辑网络进行判断，得出当前着法在当前棋局局面下的价值。另外一种方法略微抽象，我们把当前落子着法看成是棋盘的一项特征值，将其合并到已有的特征中去，形成新的一个图层，接着只需要将手工编辑好的特征输入卷积网络，我们就可以直接得到着法对应棋面的价值了。后一种方式不仅在编码实现上更简单，而且网络结构的复杂度也比前一种更低。本书对应的源码采用了前一种方法。这么做的目的是为了展示如何使用Keras来拼接网络。由于Keras的文档对这方面的介绍很少，我希望能够给读者从另外一种视角拓展对Keras在实际应用上的认识。

